# Лабораторная работа #7

## Материалы

* [Методические указания I семестр.doc](../%D0%9C%D0%B5%D1%82%D0%BE%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D0%BD%D0%B8%D1%8F%20I%20%D1%81%D0%B5%D0%BC%D0%B5%D1%81%D1%82%D1%80.doc)

## Варианты заданий

#### Во всех вариантах задания завершение программы осу-ществляется при вводе цифры 0.

1.	Выводить последовательно цифры от 0 до 9 в одно место экрана. При вводе с клавиатуры какой-либо цифры менять темп вывода. Значе-ние задержки между выводом очередного символа определять следую-щим способом: введённую цифру умножить на 29, это и будет число по-вторений цикла задержки. Для анализа нажатия клавиши использовать вектор 1Ch.
2.	Выводить в одно место экрана поочерёдно код пробела и код како-го-нибудь символа. Задержка между выводом каждого символа опреде-ляется нажатием цифровой клавиши следующим способом: введённую цифру умножить на 29, это и будет число повторений цикла задержки. Для анализа нажатия клавиши использовать вектор 1Ch.
3.	Выводить в одно место экрана введённый символ до тех пор пока не будет введён другой символ. Менять при выводе атрибут символа циклически от 1 до 15. Для анализа нажатия клавиши использовать век-тор 1Ch.
4.	Выводить в текущее положение курсора символ #. Следующий символ # выводить в позицию выше, ниже, левее или правее текущего символа, в зависимости от нажатия клавиш “8”, “2”, “4”, “6” на цифровой клавиатуре. Вывод осуществлять непрерывно с некоторой задержкой. Задержка между выводом каждого символа определяется нажатием цифровой клавиши, следующим способом: введённую цифру умножить на 29, это и будет число повторений цикла задержки. Для анализа нажа-тия клавиши использовать вектор 1Ch.
5.	Выводить в текущее положение курсора символ, введённый с клавиатуры. Этот же символ выводить в позицию выше, ниже, левее или правее текущего символа, в зависимости от нажатия клавиш “8”, “2”, “4”, “6” на цифровой клавиатуре. С клавиатуры можно ввести любую латин-скую букву, при этом, выводимый символ изменяется на введённый сим-вол. Вывод осуществлять непрерывно с некоторой задержкой. Задержка между выводом каждого символа определяется нажатием цифровой клавиши, следующим способом: введённую цифру умножить на 2 в 9 степени, это и будет число повторений цикла задержки. Для анализа нажатия клавиши использовать вектор 1Ch.
6.	В программе имеются два циклических счётчика, считающих от 0 до 23 и от 0 до 79. Их значение определяет соответственно строку и стол-бец для вывода символа на экран. При нажатии какойлибо клавиши на экран выводится символ % в положение, определяемое состоянием счётчиков на момент вывода. Для анализа нажатия клавиши использо-вать вектор 1Ch.
7.	В программе имеется циклический счётчик, считающий от 1 до 6. При нажатии любой клавиши содержимое счётчика преобразуется в ASCII код и выводится в определённое место экрана, после чего счётчик продолжает считать. Для анализа нажатия клавиши использовать вектор 1Ch.
8.	Посчитать за какое время процессор выполнить 1 000 000 команд mov DI, SI; add DI, SI; mul SI. Для подсчёта времени использовать вектор 1Ch. Выводить на экран преобразованное в ASCII коды число тиков тай-мера, затраченное на операцию.
9.	Очистить экран. Вывести несколько строк произвольного текста (атрибут 14). Перехватив прерывание печати экрана Print Screen (Int 5h), менять атрибуты всех строк экрана циклически от 1 до 15. Каждое нажа-тие клавиши Print Screen вызывает изменение атрибута.
10.	Выводить ежесекундно в правом верхнем углу экрана системное время “часы:минуты:секунды”.
11.	Вывести несколько строк произвольного текста, содержащие лишь латинские буквы. Каждые 10 секунд заглавные буквы сменяются строч-ными и т. д.
12.	В программе имеется циклический счётчик, считающий от 00h до FFh. Его значение преобразуется в ASCII код и выводится в левом верх-нем углу экрана через 18 тиков таймера. При нажатии клавиши ‘2’ время вывода уменьшается вдвое, а при повторном нажатии время вывода увеличивается в два раза. Для анализа нажатия клавиши и подсчёта числа тиков таймера использовать вектор 1Ch.
13.	Заполнить экран произвольной информацией. Перехватить преры-вание 1Ch, по нажатию клавиши ‘1’ осуществить горизонтальный скрол-линг всего экрана влево на один столбец, при нажатии клавиши ‘2’ скроллинг вправо на один столбец.
14.	Очистить экран. Вывести несколько строк произвольного текста. Перехватить прерывание экрана (Int 5h). Первый вызов этого прерыва-ния располагает строки вертикально, следующий «нормально» и т.д.
15.	Очистить экран. Заполнить его произвольной информацией. Пере-хватить прерывание экрана (Int 5h). Первый вызов этого прерывания пе-реносит строчки верхней половины экрана на место нижних, а нижние на место верхних. Следующий вызов прерывания снова меняет их ме-стами и т.д.
16.	Выводить последовательно цифры от 0 до 9 в одно место экрана. При вводе с клавиатуры какой-либо цифры менять темп вывода. Значе-ние задержки между выводом очередного символа определять следую-щим способом: введённую цифру умножить на 29, это и будет число по-вторений цикла задержки. Для анализа нажатия клавиши использовать вектор 1Ch.
17.	Выводить в одно место экрана поочерёдно код пробела и код како-го-нибудь символа. Задержка между выводом каждого символа опреде-ляется нажатием цифровой клавиши следующим способом: введённую цифру умножить на 29, это и будет число повторений цикла задержки. Для анализа нажатия клавиши использовать вектор 1Ch.
18.	Выводить в одно место экрана введённый символ до тех пор пока не будет введён другой символ. Менять при выводе атрибут символа циклически от 1 до 15. Для анализа нажатия клавиши использовать век-тор 1Ch.
19.	Выводить в текущее положение курсора символ #. Следующий символ # выводить в позицию выше, ниже, левее или правее текущего символа, в зависимости от нажатия клавиш “8”, “2”, “4”, “6” на цифровой клавиатуре. Вывод осуществлять непрерывно с некоторой задержкой. Задержка между выводом каждого символа определяется нажатием цифровой клавиши, следующим способом: введённую цифру умножить на 29, это и будет число повторений цикла задержки. Для анализа нажа-тия клавиши использовать вектор 1Ch.
20.	Выводить в текущее положение курсора символ, введённый с кла-виатуры. Этот же символ выводить в позицию выше, ниже, левее или правее текущего символа, в зависимости от нажатия клавиш “8”, “2”, “4”, “6” на цифровой клавиатуре. С клавиатуры можно ввести любую латин-скую букву, при этом, выводимый символ изменяется на введённый сим-вол. Вывод осуществлять непрерывно с некоторой задержкой. Задержка между выводом каждого символа определяется нажатием цифровой клавиши, следующим способом: введённую цифру умножить на 29, это и будет число повторений цикла задержки. Для анализа нажатия клавиши использовать вектор 1Ch.
21.	В программе имеются два циклических счётчика, считающих от 0 до 23 и от 0 до 79. Их значение определяет соответственно строку и стол-бец для вывода символа на экран. При нажатии какой-либо клавиши на экран выводится символ % в положение, определяемое состоянием счётчиков на момент вывода. Для анализа нажатия клавиши использо-вать вектор 1Ch.
22.	В программе имеется циклический счётчик, считающий от 1 до 6. При нажатии любой клавиши содержимое счётчика преобразуется в ASCII код и выводится в определённое место экрана, после чего счётчик продолжает считать. Для анализа нажатия клавиши использовать вектор 1Ch.
23.	Посчитать за какое время процессор выполнить 1 000 000 команд mov DI, SI; add DI, SI; mul SI. Для подсчёта времени использовать вектор 1Ch. Выводить на экран преобразованное в ASCII коды число тиков тай-мера, затраченное на операцию.
24.	Очистить экран. Вывести несколько строк произвольного текста (атрибут 14). Перехватив прерывание печати экрана Print Screen (Int 5h), менять атрибуты всех строк экрана циклически от 1 до 15. Каждое нажа-тие клавиши Print Screen вызывает изменение атрибута.
25.	Выводить ежесекундно в правом верхнем углу экрана системное время “часы:минуты:секунды” .

## Примечание

Увы, но так и не удалось задействовать вектор прерывания 1Ch. Но препод принимает на 100 даже без него, если объяснить ситуацию (сто пудов это эмулятор кривой).

## Работы

#### Вариант 5. Выводить в текущее положение курсора символ, введённый с клавиатуры. Этот же символ выводить в позицию выше, ниже, левее или правее текущего символа, в зависимости от нажатия клавиш “8”, “2”, “4”, “6” на цифровой клавиатуре. С клавиатуры можно ввести любую латин-скую букву, при этом, выводимый символ изменяется на введённый сим-вол. Вывод осуществлять непрерывно с некоторой задержкой. Задержка между выводом каждого символа определяется нажатием цифровой клавиши, следующим способом: введённую цифру умножить на 2 в 9 степени, это и будет число повторений цикла задержки. Для анализа нажатия клавиши использовать вектор 1Ch.

*Момент Для анализа нажатия клавиши использовать вектор 1Ch НЕ релаизован*
<details>
  <summary>Код</summary>
  
  #### Примечание.
  Задержка 2 в 9 степени оказалась слишком большой для нашего медленного эмулятора, поэтому я сделал на 2 в степени 2
  
  ```asm
  .MODEL SMALL
.STACK 100h

.DATA
    current_row db 10
    current_col db 10
    char_input db ' '
    output_char db ' '
    
    stop_msg db 0dh,0ah, "----Stop----", 0dh,0ah, "$"

.CODE
start:
    mov ax, @data
    mov ds, ax

    ; начальные модификации позиции курсора
    mov current_col, 1
    mov current_row, 1

    ; установка обработчика прерывания клавиатуры (не раб)
    ;mov ah, 25h
    ;mov al, 1Ch
    ;lea dx, keyboard_handler
    ;int 21h

    loop:
        ; ставим курсор на правильное место
        mov ah, 2
        mov dl, current_col
        mov dh, current_row
        int 10h

        ; ввод символа
        mov ah, 00h
        int 16h
        mov char_input, al

        call keyboard_handler

        jmp loop


keyboard_handler proc
    
    ; обработчик прерывания клавиатуры
    cmp char_input, 38h ; клавиша "8"
    je up
    cmp char_input, 32h ; клавиша "2"
    je down
    cmp char_input, 34h ; клавиша "4"
    je left
    cmp char_input, 36h ; клавиша "6"
    je right
    cmp char_input, 30h ; клавиша "0"
    je exit_program

    mov al, char_input  ; если это символ
    mov output_char, al

    return:
        ; вывод символа в нужную позицию
        mov ah, 02h
        mov dl, output_char
        int 21h
    ret ; для 1Ch тут нужно писать iret


up:
    ; установка новой позиции вывода символа
    mov ah, 2
    sub current_row, 1
    mov dl, current_col
    mov dh, current_row
    int 10h
    
    ; цикл задержки
    xor cx, cx
    mov cl, 8h
    shl cx, 2 ; умножаю на 2 в 9 степени (сдвиг влево на 9)
    up_delay_loop:
        nop
        loop up_delay_loop

    jmp return

down:
    ; установка новой позиции вывода символа
    mov ah, 2
    add current_row, 1
    mov dl, current_col
    mov dh, current_row
    int 10h
    
    ; цикл задержки
    xor cx, cx
    mov cl, 2h
    shl cx, 2 ; умножаю на 2 в 9 степени (сдвиг влево на 9)
    down_delay_loop:
        nop
        loop down_delay_loop

    jmp return

left:
    ; установка новой позиции вывода символа
    mov ah, 2
    sub current_col, 1
    mov dl, current_col
    mov dh, current_row
    int 10h
    
    ; цикл задержки
    xor cx, cx
    mov cl, 4h
    shl cx, 2 ; умножаю на 2 в 9 степени (сдвиг влево на 9)
    left_delay_loop:
        nop
        loop left_delay_loop

    jmp return

right:
    ; установка новой позиции вывода символа
    mov ah, 2
    add current_col, 1
    mov dl, current_col
    mov dh, current_row
    int 10h

    ; цикл задержки
    xor cx, cx
    mov cl, 6h
    shl cx, 2 ; умножаю на 2 в 9 степени (сдвиг влево на 9)
    right_delay_loop:
        nop
        loop right_delay_loop

    jmp return 

keyboard_handler endp


exit_program:
    ; выводим сообщение о том, что программа завершается
    mov ah, 09h
    lea dx, stop_msg
    int 21h

    mov ah, 4Ch     ; выходим из программы
    int 21h         ; и передаём управление потоком обратно MS DOS

end start

  ```
  
  
</details> 


#### Вариант 2

<details>
  <summary>Код</summary>
  
  ```asm
.model small
.data
    letter db 2, ?, dup('$')
    char1  db "20h$"
    char2  db "10h$"    
    delay  db 10h
        
.code
    mov ax, @data    
    mov ds, ax 
    
    mov ax, 3
    int 10h  
             

mainland:

    lea dx, char1
    mov ah, 09h   
    int 21h      
            
    call sleep
                 
    mov ax, 3
    int 10h             
                 
    lea dx, char2
    mov ah, 09h    
    int 21h   
    
    call sleep
    
    mov ax, 3
    int 10h 
    
    jmp mainland
         
         
sleep proc
    
    mov ah, 01h
    int 16h
    jz next
    
    mov ah, 00h
    int 16h
    
    sub al, 30
    mov byte ptr [delay], al 
    
    next:
    
    xor ax, ax
    mov cl, [delay]
    
    shl cx, 2
    
    lo:
        loop lo
        
    ret    
    
    
    
sleep endp             


exit:
    mov ah, 4Ch    
    int 21h         
end


  ```
  
  
</details> 
