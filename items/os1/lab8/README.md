# Лабораторная работа #8 - Шифрование LUKS

## Материалы
- [Lab-8 - Шифрование LUKS.pdf](https://github.com/xarll/vpr/blob/main/items/os1/lab8/Lab-8%20-%20%D0%A8%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20LUKS.pdf)

## Работа

### 1. Настройка ВМ

Перед началом выполнения лабораторной работы необходимо настроить ВМ.

Выбираем машину с которой будем работать, заходим в пункт **Настройки**

![1](https://user-images.githubusercontent.com/100228870/237048953-f2166cd4-0bee-41c9-b57a-7ca781d2d521.jpg)

Переходим в раздел **Носители**. Нажимаем ЛКМ на **Контроллер: SATA** и выбираем второй пункт **Добавить жесткий диск**

![2](https://user-images.githubusercontent.com/100228870/237049492-1675b3da-65c1-4a36-b9c6-db6564111ed7.jpg)

Создаём новый виртуальный жёсткий диск нажатием кнопки **Создать**.

![3](https://user-images.githubusercontent.com/100228870/237050293-3b8303dc-4dc2-4409-844f-6619458420b5.jpg)

Находим в списке ниже наш новый хард, нажимаем на него ЛКМ и подтверждаем выбор

![4](https://user-images.githubusercontent.com/100228870/237051940-8f185145-cdff-47a9-9d17-889852b46393.jpg)

Теперь на нашей ВМ установлено два виртуальных жестких диска, нажимаем **ОК** (Шифрованием второго харда мы и будем заниматься)

![5](https://user-images.githubusercontent.com/100228870/237052762-92edb7e8-7468-4b73-b388-c953c03c1f99.jpg)

Теперь запускаем ВМ и входим из под су.

### 2. Установка ПО

Устанавливаем crypsetup и smartmontools, для этого вводим в консоль следующее:
```
apt install smartmontools
```
```
apt-get install cryptsetup
```

### 3. Работа с виртуальными дисковыми пространствами.

Далее вводим в консоль
```
fdisk -l
```

Если указания выше были выполнены корректно мы увидим следующее:

Помимо первого жёсткого диска **/dev/sba**, в выводе консоли будет присутствовать добавленный вручную второй виртуальный хард **/dev/sdb** 

![6](https://user-images.githubusercontent.com/100228870/237054952-239960a2-4948-4c59-85dc-6fcf2f25c60f.jpg)

Чтобы получить более детальную информацию о дисках и разделах можно использовать:
```
lsblk
```
![7](https://user-images.githubusercontent.com/100228870/237056631-8a751b63-3a89-4aad-a64b-903a91e5f39a.jpg)

### 4. Шифрование виртуального жёсткого диска

Теперь необходимо на диске **/dev/sdb** создать зашифрованный раздел.
```
cryptsetup luksFormat /dev/sdb
```
Доказываем консоли серьёзность наших намерений введя **YES**

Далее нам предложено будет указать **ключ-фразу**, в моём случае это будет слово *key*

Ждём пару секунд, пока ВМ переварит наши действия.

![8](https://user-images.githubusercontent.com/100228870/237059300-520470df-6d10-4150-952f-a21b8e1a6854.jpg)

Далее необходимо открыть LUKS-том
```
cryptsetup luksOpen /dev/sdb encrypted_partition
```
*encrypted_partition* - название раздела (можем ввести любое своё)

Далее у нас запросят ключ-фразу. Вводим её.

![9](https://user-images.githubusercontent.com/100228870/237061513-84c536ae-d6cf-44e4-a177-de1fdebdd43c.jpg)

Если все пункты выше выполнены правильно, то том станет отображаться в **/dev/mapper/encrypted_partition**

Первый способ для проверки:
```
ls /dev/mapper
```
![10](https://github.com/coonsst/vpr/assets/100228870/41769204-c05f-4da2-9d89-b7b3a65c91c6)

Второй способ для проверки:
```
lsblk
```
С помощью утилиты мы можем увидеть следующее:

Виртуальный жёсткий диск **/dev/sdb** имеет зашифрованный том **encrypted_partition** (подтверждением этому служит слово **krypt** в столбце **TYPE**)

![11](https://github.com/coonsst/vpr/assets/100228870/e849a485-542f-4a33-96ad-3cc600911d40)

Теперь необходимо проверить состояние зашифрованного диска, вводим в консоль:
```
cryptsetup status encrypted_partition
```
В выводе мы увидим тип и метку тома:

![12](https://github.com/coonsst/vpr/assets/100228870/4db9b755-812c-4b5f-9d66-9f7b1902f03e)

Теперь у вас есть защищенный паролем шифрованный диск. 

Следующим этапом будет создание файловой системы на этом диске, чтобы операционная система могла использовать ее для хранения файлов.

Сейчас мы должны создать и монтировать файловую систему. Сначала посмотрим на текущее доступное дисковое пространство ВМ.
```
df -h
```

![13](https://github.com/coonsst/vpr/assets/100228870/db954abe-6a6b-4d81-8526-d5fda291ad28)

Сейчас /dev/mapper/encrypted_partition не отображается в этом списке, потому что том еще не доступен для сервера. Чтобы сделать его доступным, необходимо создать и смонтировать файловую систему.

### 5. Монтирование файловой системы на зашифрованном разделе

Используем утилиту **mkfs**, для создания файловой системы **ext4** в томе.
```
mkfs.ext4 /dev/mapper/encrypted_partition 
```
![14](https://github.com/coonsst/vpr/assets/100228870/cae3f500-df83-4ce7-b79f-9a8050ba1e6d)

Когда файловая система будет создана, можно её смонтировать, что означает, что она будет доступна для операционной системы нашей ВМ.

*!Правилом хорошего тона является монтирование файловых систем в папки "mnt" и "media". Обычно папку "mnt" используют для монтирования разделов, а папку "media" для монтирования съемных носителей информации!*

Перед монтированием создадим папку **luks_dir** в директории **/mnt/**
```
mkdir /mnt/luks_dir
```
![15](https://github.com/coonsst/vpr/assets/100228870/d0a5d91a-ce53-46d0-bee6-ad0c244833b3)

Создаём точку монтирования, к которой будет прикреплена файловая система. 

Смонтируем файловую систему в новую папку.
```
mount /dev/mapper/encrypted_partition /mnt/luks_dir
```
![16](https://github.com/coonsst/vpr/assets/100228870/cf1b6265-1257-4450-9fbe-a23da7eb0860)

Чтобы убедиться, что все работает, проверим доступное дисковое пространство ВМ:
```
df -h
```
![17](https://github.com/coonsst/vpr/assets/100228870/67b93d29-5678-4d1a-8c59-2eefee239d65)

Теперь в списке появится **/dev/mapper/encrypted_partition**

Это означает, что зашифрованная файловая система подключена и доступна для использования.

### 6. Добавление ключей (Фраза & Файл)

Добавим новую ключевую фразу как того требует задание:
```
cryptsetup luksAddKey /dev/sdb
```
Для этого у нас потребуют любую уже существующую ключ-фразу (В своём случае я ввожу *key*)

А после добавляем новую ключ-фразу, пускай это будет *key2*

![18](https://github.com/coonsst/vpr/assets/100228870/3337544d-7988-4c47-a99c-11a9d9bbc042)

Теперь необходимо посмотреть количество используемых ключей для нашего раздела и узнать сколько свободных слотов осталось.

```
cryptsetup luksDump /dev/sdb
```
![19](https://github.com/coonsst/vpr/assets/100228870/fec6b75d-bf57-4fd6-9577-902efcaeeaf9)

Но! Файл очень большой, а нам надо *посмотреть его построчно*. Поэтому в домашней директории создаём файл **l_dump**
```
touch ~/l_dump
```
![20](https://github.com/coonsst/vpr/assets/100228870/49658436-2cdc-4228-a780-953f45b10cca)

Далее записываем список ключей в этот файл.
```
cryptsetup luksDump /dev/sdb >> ~/l_dump
```
И открываем **l_dump** через редактор **nano**
```
nano ~/l_dump
```
В файле мы видим следующее:

Слоты 0 (ключ **key**) и 1 (ключ **key2**) заняты. Соответственно остальные слоты (2,3,4,5,6,7) свободны.

![21](https://github.com/coonsst/vpr/assets/100228870/0235b5b9-2a35-4a49-98e5-40a3d528e95a)

Теперь необходимо создать ключ-файл.
```
dd if=/dev/random of=~/luks.key bs=1 count=256
```
![22](https://github.com/coonsst/vpr/assets/100228870/15ff1447-6c70-49f5-96ae-726fc154d9e3)

!!Также необходимо изменить права файла, разрешив только чтение владельцу (только руту, в нашем случае)!!
```
chmod 0400 /root/luks.key
```
![22 1](https://github.com/coonsst/vpr/assets/100228870/000dd4df-d73c-4424-a351-80be69df5006)

Проверяем наличие файла и его права в домашней директории рута:
```
ls -l ~/luks.key
```
![23](https://github.com/coonsst/vpr/assets/100228870/efba7391-fa88-4616-a119-fe54290c68cf)

Ключ-файл существует и может быть прочитан только рутом, переходим к следующему шагу.

### 7. Добавление ключей в слоты

Добавляем файл-ключ в доступный слот.
```
cryptsetup luksAddKey /dev/sdb ~/luks.key
```
Вводим любой из уже существующих ключей для прохождения верификации.
![24](https://github.com/coonsst/vpr/assets/100228870/89865aed-d50b-4b9b-a68e-b0595bfff24a)

Правильность наших действий можно проверить. Для этого перезаписываем файл в котором мы храним информацию о слотах.
```
cryptsetup luksDump /dev/sdb > ~/l_dump
```
![26](https://github.com/coonsst/vpr/assets/100228870/a1142050-5f70-4109-aa79-115103088ca7)

Открываем файл через редактор **nano** и смотрим количество занятых слотов. Если мы сделали всё правильно, то слот **2** будет занят файлом-ключом.
```
nano ~/l_dump
```
![27](https://github.com/coonsst/vpr/assets/100228870/8fe040ff-1f2d-47e0-b0f0-2f01b7251842)

### 8. Удалений ключей из слотов

Теперь необходимо научиться удалять из слотов ключи. Существует два способа удаления.

Предлагаю для наглядности создать два ключа и удалить их.

Создаём 2 ключа, как и раньше, используя:
```
cryptsetup luksAddKey /dev/sdb
```
![28](https://github.com/coonsst/vpr/assets/100228870/fbac3f01-1bd5-47f6-8ad4-4f562ff6ff2e)

Проверяем наличие ключей переписывая файл **l_dump** и смотрим заняты ли слоты **3** и **4**
```
cryptsetup luksDump /dev/sdb > ~/l_dump
```
Как мы можем заметить слоты заняты, значит всё сделано правильно.
![29](https://github.com/coonsst/vpr/assets/100228870/11f08dcb-a2e9-49cc-a2cf-6b4e96eb9993)


**Переходим к удалению ключей**

Первый способ. Удаление ключа по номеру его слота:

Удалять будем **4** слот. При удалении потребуется ввести один из *СУЩЕСТВУЮЩИХ* ключей
```
cryptsetup luksKillSlot /dev/sdb 4
```
![30](https://github.com/coonsst/vpr/assets/100228870/57f6ce81-e206-44fd-86de-360ce43b2ed8)

Второй способ. Удаление ключа по ключу-фразе:

Удалять будем **3** слот. Вводить необходимо *УДАЛЯЕМУЮ* ключ-фразу.
```
cryptsetup luksRemoveKey /dev/sdb
```
![31](https://github.com/coonsst/vpr/assets/100228870/a7455563-c661-46b6-82c2-ce76bbfaafe2)

Проверяем удалились ли ключи переписывая файл **l_dump** и смотрим существуют ли слоты **3** и **4**
```
cryptsetup luksDump /dev/sdb > ~/l_dump
```
Слоты освободились, значит всё сделано правильно.
![32](https://github.com/coonsst/vpr/assets/100228870/b1c3f534-4182-4616-b198-9dbf3609af26)

### 9. Работа с ключом-файлом

!! Бонус. Удаление ключа из слота с помощью файла-ключа. !!

Не знаю необходимо ли это. Но Долгов может потребовать. Поэтому пускай будет.

Для рассмотрения этого случая я специально сгенерировал ключ-фразу на слот **3**. Его и буду удалять.
```
cryptsetup luksKillSlot /dev/sdb 3 --key-file=/root/luks.key
```
С помощью добавления в конец команды *--key-file=/root/luks.key* можно выполнять действия в Luks. (Используя ключ-файл, ввод ключа-фразы не требуется)

Проведём поиск по цифре **3** (слот, который занимал ключ) в **luksDump** для того, чтобы снова не переписывать файл. Смотрим результат.
```
cryptsetup luksDump /dev/sdb | grep "3"
```
Третий ключ не найден, значит удаление с помощью ключ-файла работает корректно.

![33](https://github.com/coonsst/vpr/assets/100228870/5d46514f-c2fd-4884-a7f8-973b1a2392de)

### 10. Взаимодействие с зашифрованным разделом

На данный момент наш шифрованный раздел открыт и файловая система смонтирована - это означает, что мы можем читать/записывать на нём информацию.

Переходим в директорию раздела
```
cd /mnt/luks_dir
```
И смотрим, что в нём есть.
```
ls
```
Сейчас тут существует только директория **lost+found**, которая необходима для работы утилиты **fsck**

![34](https://github.com/xarll/vpr/assets/100228870/3d46a325-aac0-4981-86dd-e90bfcef6612)

Для демонстрации корректной работы шифрованного раздела предлагаю скопировать файл содержащий **luksDump** (информацию о ключах в слотах) в наш раздел.
```
cp ~/l_dump /mnt/liks_dir
```
Проверим наличие файла в каталоге
```
ls /mnt/luks_dir
```
![35](https://github.com/xarll/vpr/assets/100228870/7e045cd9-1ad7-41d5-a48f-5083b084dc7f)

Файл успешно скопировался (если есть желание, то можно просмотреть его с помощью **nano** и убедиться, что все данные на месте)

Всё работает.

### 11. Размонтирование файловой системы и блокировка зашифрованного диска

После того, как мы проделали какие-либо действия необходимо размонтировать файловую систему.

```
umount /mnt/luks_dir
```
```
cryptsetup luksClose encrypted_partition
```

Проверим статус зашифрованного раздела. Если всё верно, то он будет неактивный.
```
cryptsetup status encrypted_partition
```
![36](https://github.com/xarll/vpr/assets/100228870/ae25e563-cfd8-4255-984f-9ab3552b1234)


### 12. Проверка шифрования виртуального диска

На данный момент раздел зашифрован и неактивен. Включим его и проверим на месте ли наш скопированный файл.
```
cryptsetup luksOpen /dev/sdb encrypted_partition
```
Вводим ключ-фразу и проверяем активен ли раздел.
```
cryptsetup status encrypted_partition
```
**/dev/mepper/encrypted_partition is active** - раздел готов к работе.

![37](https://github.com/xarll/vpr/assets/100228870/5cf8ab5b-7df0-4623-b3a8-edbc8c1432e0)

Теперь смонтируем файловую систему по нашему пути.
```
mount /dev/mapper/encrypted_partition /mnt/luks_dir
```
Просмотрим остался ли наш файл **l_dump**. 
```
ls /mnt/luks_dir
```
Файл существует - всё правильно.

![38](https://github.com/xarll/vpr/assets/100228870/a448a58d-81b0-4331-af29-47098b54d5c5)

### 13. Автоматическое монтирование раздела

Чтобы ОС сама научилась подключать и монтировать нужные криптованные устройства во время загрузки, а затем корректно отключать их во время останова системы, необходимо добавить следующее.

Отредактируем файл **crypttab**
```
nano /etc/crypttab
```
Добавим в него следующее:
```
encrypted_partition /dev/sdb none luks,cipher=aes-cbc-essiv:sha256
```
Сохраняем файл **Ctrl + S**.

![39](https://github.com/xarll/vpr/assets/100228870/82d6e1fa-340a-455a-bbf9-7ba6b34b3805)

Далее отредактируем файл **fstab**
```
nano /etc/fstab
```
Добавим в него следующее:
```
/dev/mapper/encrypted_partition /mnt/luks_dir ext4 defaults 0 0
```
Сохраняем файл **Ctrl + S**.

![40](https://github.com/xarll/vpr/assets/100228870/0353eb7e-8111-4b55-acb9-4e1df2dbf05b)

Теперь во время каждой загрузки ОС будет спрашивать пароль для доступа к криптованному разделу, если он будет указан не правильно - загрузка остановится.

Перезапустим машину, чтобы проверить корректность автомонтирования.
```
reboot
```
Если мы наблюдаем следующую картину - всё верно. Вводим ключ, для начала работы с ВМ.

![41](https://github.com/xarll/vpr/assets/100228870/b013a85a-fc42-4b78-8982-8645a823cd6a)

Автоматическое монтирование раздела реализовано.

### 14. Создание флеш-накопителя

Выбираем машину с которой будем работать, заходим в пункт **Настройки** -> **Носители**.

Нажимаем "Добавить новый контроллер" (зелёная дискета) и в выпавшем меню выбираем **USB**

![5-1](https://github.com/xarll/vpr/assets/100228870/5273d24d-9834-42e5-9cbb-1c1b6befa7e2)

После того, как графа **Контроллер USB** появилась нажимаем на неё ЛКМ и выбираем **Добавить жесткий диск**

![5-2](https://github.com/xarll/vpr/assets/100228870/4f3682b5-247f-48d1-a18d-b22cec73a725)

Создаём новый виртуальный флеш-накопитель нажатием кнопки **Создать**.

![5-3](https://github.com/xarll/vpr/assets/100228870/8fa48953-d70c-4de6-96bb-bffd6f288be6)

Находим в списке ниже наш виртуальный флеш-накопитель, нажимаем на него ЛКМ и подтверждаем выбор

![5-4](https://github.com/xarll/vpr/assets/100228870/2cca32c9-f77c-4e42-b1c5-973ee4935a6e)

Заходим в ВМ. Логинимся под рутом. Смотрим информацию о дисках.
```
lsblk
```
Сразу можем обнаружить накопитель **/dev/sdc** - это и есть наш флеш-накопитель. 

![42](https://github.com/xarll/vpr/assets/100228870/ac7f63f2-27a5-416d-86fb-418addb9775c)

### 15. Шифрование флеш-накопителя

Создадим зашифрованный раздел.
```
cryptsetup luksFormat /dev/sdc
```
Подтверждаем форматирование. Создаём ключ-фразу.

![43](https://github.com/xarll/vpr/assets/100228870/26108fbf-7fb2-4469-ae62-00a16e2e92de)

Инициализируем новый раздел.
```
cryptsetup luksOpen /dev/sdc flash_encrypted_partition
```
Вводим ключ-фразу, выбранную при создании данного раздела.

![44](https://github.com/xarll/vpr/assets/100228870/f58f4f9f-0c84-4b99-ba27-9bada449f542)

Проверяем тип раздела.
```
lsblk
```
Раздел шифрованный. Всё отлично.

![45](https://github.com/xarll/vpr/assets/100228870/bb392743-2361-40fc-9221-727b70320c03)

### 16. Монтирование файловой системе на зашифрованном флеш-накопителе

Используем утилиту **mkfs**, для создания файловой системы **fat** в томе.
```
mkfs.fat /dev/mapper/flash_encrypted_partition 
```

![46](https://github.com/xarll/vpr/assets/100228870/63a10646-fbc6-4449-8348-e6e2d041e1cc)

Когда файловая система будет создана, можно её смонтировать, что означает, что она будет доступна для операционной системы нашей ВМ.

*!Повторяю! Правилом хорошего тона является монтирование файловых систем в папки "mnt" и "media". Обычно папку "mnt" используют для монтирования разделов, а папку "media" для монтирования съемных носителей информации!*

Перед монтированием создадим папку **flash_luks_dir** в директории **/media/**
```
mkdir /media/flash_luks_dir
```
![47](https://github.com/xarll/vpr/assets/100228870/82db3504-9e1c-4ab9-80c3-9649bd676733)

Создаём точку монтирования, к которой будет прикреплена файловая система. 

Смонтируем файловую систему в новую папку.
```
mount /dev/mapper/flash_encrypted_partition /media/flash_luks_dir
```
![48](https://github.com/xarll/vpr/assets/100228870/47bed8df-648d-4238-a66f-d75ed7777734)

### 17. Автоматическое монтирование флеш-накопителя

Отредактируем файл crypttab
```
nano /etc/crypttab
```
Добавим в него новую строку:

```
flash_encrypted_partition /dev/sdc none luks,cipher=aes-cbc-essiv:sha256
Сохраняем файл Ctrl + S.
```

![49](https://github.com/coonsst/vpr/assets/100228870/1a94b20b-8cc9-4ea9-b07b-4de081d47947)

Далее отредактируем файл fstab
```
nano /etc/fstab
```
Добавим в него новую строку:
```
/dev/mapper/flash_encrypted_partition /media/flash_luks_dir vfat defaults 0 0
```
Сохраняем файл Ctrl + S.

![50](https://github.com/coonsst/vpr/assets/100228870/39eaaeaf-6fc5-4b29-a3a8-c3c7bd3f6d92)

Теперь во время каждой загрузки ОС будет спрашивать пароль для доступа к криптованному разделу, а после накопителю, если один из паролей будет указан не правильно - загрузка остановится.

Перезапустим машину, чтобы проверить корректность автомонтирования.
```
reboot
```
Если мы наблюдаем следующую картину - всё верно. Вводим ключи, для начала работы с ВМ.

(Прим. мои разделы называются теперь по другому т.к. я продолжил выполнение лабы за другой ВМ)

![51](https://github.com/coonsst/vpr/assets/100228870/c5a039e1-840b-4ead-9495-759c78b723b8)

Автоматическое монтирование флеш-накопителя реализовано.

### 18. Шифрование директории 

Можно производить любыми доступными инструментами.

## Контрольные вопросы

**1. В каком файле необходимо указывать путь к ключу для автоматического монтирования зашифрованного раздела/диска?**

fstab - один из конфигурационных файлов в UNIX-подобных системах, который содержит информацию о различных файловых системах и устройствах хранения информации компьютера; описывает, как диск (раздел) будет использоваться или как будет интегрирован в систему.


**2. Сколько слотов для хранения ключей содержит LUKS?**


Для каждого файла имеется возможность записать до 8-ти ключей. Нумерация идёт от 0 до 7. Проверить кол-во ключей у раздела можно командой
```
sryptsetup luksDump /dev/part_name 
```
(где *part_name - имя диска или раздела)


**3. С помощью какой программы можно получить доступ к зашифрованному разделу/диску (открыть раздел/диск)?**

Программа - cryptsetup.

Открыть зашифрованный раздел. (*part_name - имя диска/раздела, *crypt_device_name - имя, данное диску/раздела при его шифрованнии)
```
cryptsetup luksOpen /dev/part_name crypt_device_name 
```

Закрыть зашифрованный раздел. (*part_name - имя диска/раздела, *crypt_device_name - имя, данное диску/раздела при его шифрованнии)
```
cryptsetup luksClose /dev/part_name crypt_device_name 
```

**4. Если вы планируете осуществлять мониторинг жёстких дисков, какой пакет нужно установить?**

```
smartmontools
```

**5. Какая утилита ориентирована на работу со SCSI устройствами (включая SATA, IEEE1394 и USB)?**

Не уверен, возможно:

```
fdisk
```

**6. С помощью какой утилиты можно уменьшить шум от диска?**

```
hdparam
```
